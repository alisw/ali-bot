#!/usr/bin/env python
from __future__ import print_function

import os
import random
import sys
import time

from commands import getstatusoutput
from argparse import ArgumentParser
from operator import itemgetter
from alibot_helpers.github_utilities import GithubCachedClient
from alibot_helpers.github_utilities import PickledCache


def getStatusInfo(statuses, args):
    reviewed = False
    tested = False
    success = False

    for s in statuses:
        if args.checkName and s["context"] == args.checkName:
            reviewed = True
            tested = s["state"] in ["success", "error", "failure"]
            success = s["state"] in ["success"]
            break
        if s["context"] == args.status and s["state"] == "success":
            reviewed = True
    return {
        "tested": tested,
        "success": success,
        "reviewed": reviewed,
        "random": random.random()
    }


def processOnePull(cgh, pull, repo_name, args, sorted_pulls, trustedTeam):
    # Decide whether or not to show the PR based on how many
    # workers are there and the current worker id.

    modPoolSize = int(pull["head"]["sha"][0], 16) % args.workersPoolSize
    if modPoolSize != args.workerIndex:
        return

    item = {
        "number": pull["number"],
        "sha": pull["head"]["sha"],
        "reviewed": False,
        "tested": False,
        "success": False,
        "random": random.random()
    }

    # If we specified a status to approve changes to tests we need to
    # retrieve all the statuses.
    # If we specified a check name to prioritize PR building, we need to
    # retrieve all the statuses.
    if args.status or args.checkName:
        all_statuses = cgh.get("/repos/{repo_name}/commits/{ref}/statuses",
                               repo_name=repo_name,
                               ref=pull["head"]["sha"])
        item.update(getStatusInfo(all_statuses, args))

    if item.get("reviewed"):
        sorted_pulls.append(item)
        return

    # If we specified a list of trusted users, a trusted team or if we
    # trust collaborators, we need to check if this is the case for the
    # given PR. Notice that given that these will actually consume API
    # calls, you need to be careful about what you enable.
    if pull["user"]["login"] in trusted:
        item.update({"reviewed": True})

    if trustedTeam and cgh.get(url="/teams/{team_id}/memberships/{login}",
                               team_id=trustedTeam,
                               login=pull["user"]["login"]):
        item.update({"reviewed": True})

    if args.trustCollaborators:
        cgh.get("/repos/{repo_name}/collaborators/{login}/permission",
                repo_name=repo_name,
                login=pull["user"]["login"],
                stable_api=False)
        item.update({"reviewed": True})

    sorted_pulls.append(item)


def processMainBranch(cgh, repo_name, branch_ref, args, sorted_pulls):
    # Print the ref of the main branch as well
    branch = cgh.get("/repos/{repo_name}/branches/{branch_ref}",
                     repo_name=repo_name,
                     branch_ref=branch_ref)

    # Decide whether or not to show the PR based on how many
    # workers are there and the current worker id.
    modPoolSize = int(branch["commit"]["sha"][0], 16) % args.workersPoolSize
    if modPoolSize != args.workerIndex:
        return

    all_statuses = cgh.get("/repos/{repo_name}/commits/{ref}/statuses",
                           repo_name=repo_name,
                           ref=branch["commit"]["sha"])
    item = {"number": branch_ref, "sha": branch["commit"]["sha"]}
    item.update(getStatusInfo(all_statuses, args))
    sorted_pulls.append(item)


def parseArgs():
    parser = ArgumentParser(usage="list-branch-prs <repo>@<branch>")
    parser.add_argument("branch",
                        help="Branch of which to list hashes for open prs")
    parser.add_argument("--trusted",
                        default="review",
                        help="Users whose request you trust")
    parser.add_argument("--trusted-team",
                        dest="trustedTeam",
                        help="Trust provided team")
    parser.add_argument("--trust-collaborators",
                        dest="trustCollaborators",
                        action="store_true",
                        help="Trust all collaborators")
    parser.add_argument("--show-main-branch",
                        dest="showMainBranch",
                        default=False,
                        action="store_true",
                        help=("Also show reference for the main branch, "
                              " not only for the PRs"))
    parser.add_argument("--status",
                        default="review",
                        help="Commit status which is considered trustworthy")
    parser.add_argument("--check-name",
                        dest="checkName",
                        default="",
                        help="Name of the check which we want to perform")
    parser.add_argument("--worker-index",
                        dest="workerIndex",
                        type=int,
                        default=0,
                        help="Index for the current worker")
    parser.add_argument("--workers-pool-size",
                        dest="workersPoolSize",
                        type=int,
                        default=1,
                        help="Total number of workers")
    parser.add_argument("--script",
                        dest="script",
                        default="",
                        help="Execute a script on the resulting PR")
    parser.add_argument("--timeout",
                        dest="timeout",
                        default=100,
                        type=int,
                        help="Timeout between one run and the other")

    return parser.parse_args()


if __name__ == "__main__":
    args = parseArgs()

    repo_name = args.branch.split("@")[0]
    org = repo_name.split("/")[0]
    branch_ref = args.branch.split("@")[1] if "@" in args.branch else "master"
    trusted = args.trusted.split(",")

    token = os.environ.get("GITHUB_TOKEN")

    # We instanciate our custom Github client to limit the amount of API calls
    cache = PickledCache(".cached_github_client_cache")
    with GithubCachedClient(token=token, cache=cache) as cgh:
        # We get all the pull requests and put
        # them in a dictionary sorted by ID
        pulls = cgh.get("/repos/{repo_name}/pulls?base={base}",
                        repo_name=repo_name,
                        base=branch_ref)

        # Get the team for which we consider safe for test
        trustedTeam = None
        for team in cgh.get("/orgs/{org}/teams", org=org):
            if team["name"] == args.trustedTeam:
                trustedTeam = team["id"]

        while True:
            # Get only the updates
            sorted_pulls = []
            for pull in pulls:
                try:
                    print("Processing: %s" % pull["number"], file=sys.stderr)
                    processOnePull(cgh,
                                   pull,
                                   repo_name,
                                   args,
                                   sorted_pulls,
                                   trustedTeam)
                    print("Processing: %s. Done." % pull["number"],
                          file=sys.stderr)
                except RuntimeError as e:
                    print(e, file=sys.stderr)

            if args.showMainBranch:
                try:
                    processMainBranch(cgh,
                                      repo_name,
                                      branch_ref,
                                      args,
                                      sorted_pulls)
                except RuntimeError as e:
                    print(e, file=sys.stderr)

            sorted_pulls.sort(key=itemgetter("tested", "success", "random"))

            reviewed_pulls = [p for p in sorted_pulls if p["reviewed"]]
            not_tested_pulls = [p for p in reviewed_pulls if not p["tested"]]
            not_successful = [p for p in reviewed_pulls if p["tested"] and not p["success"]]

            actionable_pulls = (not_tested_pulls or
                                not_successful[:1] or
                                reviewed_pulls[:1])

            for x in actionable_pulls:
                prId = "%(number)s@%(sha)s" % x
                print(prId)
                if args.script:
                    err, out = getstatusoutput("%s %s" % (args.script, prId))
                    print(out)

            cgh.printStats() 

            # No script provided, run in one shot mode.
            if not args.script:
                break
            time.sleep(args.timeout)
