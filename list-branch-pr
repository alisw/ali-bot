#!/usr/bin/env python
from __future__ import print_function

import os
import random
import sys
import time
import pickle

from commands import getstatusoutput
from argparse import ArgumentParser
from sys import exit
from operator import itemgetter
from alibot_helpers.github_utilities import printStats
from alibot_helpers.github_utilities import dumpCommits, loadCommits
from alibot_helpers.github_utilities import GithubCachedClient

import atexit

from github import Github

def getStatusInfo(statuses, args):
  reviewed = False
  tested = False
  success = False

  for s in statuses:
    if args.checkName and s["context"] == args.checkName:
      reviewed = True
      tested = s["state"] in ["success", "error", "failure"]
      success = s["state"] in ["success"]
      break
    if s["context"] == args.status and s["state"] == "success":
      reviewed = True
  return {"tested": tested,
          "success": success,
          "reviewed": reviewed,
          "random": random.random()}


def processOnePull(cgh, pull, repo_name, args, sorted_pulls, trustedTeam):
  # Decide whether or not to show the PR based on how many
  # workers are there and the current worker id.
  if ((int(pull["head"]["sha"][0], 16)) % args.workersPoolSize) != args.workerIndex:
    return

  item = {"number": pull["number"],
          "sha": pull["head"]["sha"],
          "reviewed": False,
          "tested": False,
          "success": False,
          "random": random.random()}

  # If we specified a status to approve changes to tests we need to
  # retrieve all the statuses.
  # If we specified a check name to prioritize PR building, we need to
  # retrieve all the statuses.
  if args.status or args.checkName:
    all_statuses = cgh.request("GET", "/repos/{repo_name}/commits/{ref}/statuses",
                               repo_name=repo_name,
                               ref=pull["head"]["sha"])
    item.update(getStatusInfo(all_statuses, args))

  if item.get("reviewed"):
    sorted_pulls.append(item)
    return

  # If we specified a list of trusted users, a trusted team or if we
  # trust collaborators, we need to check if this is the case for the
  # given PR. Notice that given that these will actually consume API
  # calls, you need to be careful about what you enable.
  if pull["user"]["login"] in trusted:
    item.update({"reviewed": True})
  if trustedTeam and cgh.request(method="GET", url="/teams/{team_id}/memberships/{login}", team_id=trustedTeam, login=pull["user"]["login"]):
    item.update({"reviewed": True})
  if args.trustCollaborators:
    permission = cgh.request(method="GET",
                             url="/repos/{repo_name}/collaborators/{login}/permission",
                             repo_name=repo_name,
                             login=pull["user"]["login"],
                             stable_api=False)
    item.update({"reviewed": True})
  sorted_pulls.append(item)

def processMainBranch(cgh, repo_name, branch_ref, args, sorted_pulls):
  # Print the ref of the main branch as well
  branch = cgh.request("GET", "/repos/{repo_name}/branches/{branch_ref}",
                        repo_name=repo_name,
                        branch_ref=branch_ref)
  # Decide whether or not to show the PR based on how many
  # workers are there and the current worker id.
  if (int(branch["commit"]["sha"][0], 16) % args.workersPoolSize) != args.workerIndex:
    return

  all_statuses = cgh.request("GET", "/repos/{repo_name}/commits/{ref}/statuses",
                             repo_name=repo_name,
                             ref=branch["commit"]["sha"])
  item = {"number": branch_ref, "sha": branch["commit"]["sha"]}
  item.update(getStatusInfo(all_statuses, args))
  sorted_pulls.append(item)

if __name__ == "__main__":
  gh = Github(login_or_token=os.environ["GITHUB_TOKEN"])
  printStats(gh)
  parser = ArgumentParser(usage="list-branch-prs <repo>@<branch>")
  parser.add_argument("branch",
                      help="Branch of which to list hashes for open prs")
  parser.add_argument("--trusted", default="review", help="Users whose request you trust")
  parser.add_argument("--trusted-team", dest="trustedTeam", default=None, help="Trust provided team")
  parser.add_argument("--trust-collaborators", dest="trustCollaborators", default=None, action="store_true", help="Trust all collaborators")
  parser.add_argument("--show-main-branch", dest="showMainBranch", default=False, action="store_true",
                      help="Also show reference for the main branch, not only for the PRs")
  parser.add_argument("--status", default="review",
                      help="Commit status which is considered trustworthy")
  parser.add_argument("--check-name", dest="checkName", default="",
                      help="Name of the check which we want to perform")
  parser.add_argument("--worker-index", dest="workerIndex", type=int, default=0,
                      help="Index for the current worker")
  parser.add_argument("--workers-pool-size", dest="workersPoolSize", type=int, default=1,
                      help="Total number of workers")
  parser.add_argument("--script", dest="script", default="",
                      help="Execute a script on the resulting PR")
  parser.add_argument("--timeout", dest="timeout", default=100, type=int,
                      help="Timeout between one run and the other")

  args = parser.parse_args()

  repo_name = args.branch.split("@")[0]
  org = repo_name.split("/")[0]
  branch_ref = args.branch.split("@")[1] if "@" in args.branch else "master"
  trusted = args.trusted.split(",")

  token = os.environ.get("GITHUB_TOKEN", None)
  opts = {"login_or_token": token} if token else {}
  gh = Github(**opts)

  # We instanciate our custom Github client to limit the amount of API calls
  cgh = GithubCachedClient(token=token)
  cgh.loadCache(".cached_github_client_cache")

  # We get all the pull requests and put them in a dictionary sorted by ID
  #pulls = repo.get_pulls(state="open", base=branch_ref)
  pulls = cgh.request("GET", "/repos/{repo_name}/pulls?base={base}",
                      repo_name=repo_name,
                      base=branch_ref)

  # Get the team for which we consider safe for test
  trustedTeam = None
  for team in cgh.request("GET", "/orgs/{org}/teams", org=org):
    if team["name"] == args.trustedTeam:
      trustedTeam = team["id"]

  while True:
    # Get only the updates
    sorted_pulls = []
    for pull in pulls:
      try:
        print("Processing: %s" % pull["number"], file=sys.stderr)
        processOnePull(cgh, pull, repo_name, args, sorted_pulls, trustedTeam)
        print("Processing: %s. Done." % pull["number"], file=sys.stderr)
      except RuntimeError as e:
        print(e, file=sys.stderr)

    if args.showMainBranch:
      try:
        processMainBranch(cgh, repo_name, branch_ref, args, sorted_pulls)
      except RuntimeError as e:
        print(e, file=sys.stderr)

    sorted_pulls.sort(key=itemgetter("tested", "success", "random"))

    reviewed_pulls = [p for p in sorted_pulls if p["reviewed"]]
    not_tested_pulls = [p for p in reviewed_pulls if not p["tested"]]
    not_successful = [p for p in reviewed_pulls if p["tested"] and not p["success"]]

    actionable_pulls = not_tested_pulls or not_successful[:1] or reviewed_pulls[:1]

    for x in actionable_pulls:
      prId = "%(number)s@%(sha)s" % x
      print(prId)
      if args.script:
        err, out = getstatusoutput("%s %s" % (args.script, prId))
        print(out)

    printStats(gh)
    # No script provided, run in one shot mode.
    if not args.script:
      break
    time.sleep(args.timeout)

  cgh.dumpCache(".cached_github_client_cache")
