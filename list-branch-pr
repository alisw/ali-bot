#!/usr/bin/env python
from __future__ import print_function

import os
import random
import sys
import time
import pickle

from commands import getstatusoutput
from argparse import ArgumentParser
from sys import exit
from operator import itemgetter
from alibot_helpers.github_utilities import printStats
from alibot_helpers.github_utilities import dumpCommits, loadCommits
import atexit

from github import Github

CACHED_COMMITS = loadCommits()

def getStatusInfo(statuses, args):
  reviewed = False
  tested = False
  success = False

  for s in statuses:
    if args.checkName and s.context == args.checkName:
      reviewed = True
      tested = s.state in ["success", "error", "failure"]
      success = s.state in ["success"]
      break
    if s.context == args.status and s.state == "success":
      reviewed = True
  return {"tested": tested,
          "success": success,
          "reviewed": reviewed,
          "random": random.random()}


def processOnePull(gh, pull, repo, args, sorted_pulls, trustedTeam):
  # Decide whether or not to show the PR based on how many
  # workers are there and the current worker id.
  if ((int(pull.head.sha[0], 16)) % args.workersPoolSize) != args.workerIndex:
    return

  # Not sure why pygithub does not handle this internally.
  commit = CACHED_COMMITS.get(pull.head.sha) or repo.get_commit(pull.head.sha)
  CACHED_COMMITS[pull.head.sha] = commit

  all_statuses = commit.get_statuses()
  item = {"number": pull.number, "sha": commit.sha}
  item.update(getStatusInfo(all_statuses, args))
  if not item.get("reviewed") and pull.user.login in trusted:
    item.update({"reviewed": True})
  elif not item.get("reviewed") and trustedTeam and trustedTeam.has_in_members(pull.user):
    item.update({"reviewed": True})
  elif not item.get("reviewed") and args.trustCollaborators and repo.has_in_collaborators(pull.user):
    item.update({"reviewed": True})
  sorted_pulls.append(item)

def processMainBranch(repo, branch_ref, args, sorted_pulls):
  # Print the ref of the main branch as well
  branch = repo.get_branch(branch_ref)
  # Decide whether or not to show the PR based on how many
  # workers are there and the current worker id.
  if (int(branch.commit.sha[0], 16) % args.workersPoolSize) != args.workerIndex:
    return

  all_statuses = branch.commit.get_statuses()
  item = {"number": branch_ref, "sha": branch.commit.sha}
  item.update(getStatusInfo(all_statuses, args))
  sorted_pulls.append(item)

if __name__ == "__main__":
  gh = Github(login_or_token=os.environ["GITHUB_TOKEN"])
  atexit.register(lambda : printStats(gh))
  printStats(gh)
  parser = ArgumentParser(usage="list-branch-prs <repo>@<branch>")
  parser.add_argument("branch",
                      help="Branch of which to list hashes for open prs")
  parser.add_argument("--trusted", default="", help="Users whose request you trust")
  parser.add_argument("--trusted-team", dest="trustedTeam", default=None, help="Trust provided team")
  parser.add_argument("--trust-collaborators", dest="trustCollaborators", default=None, help="Trust all collaborators")
  parser.add_argument("--show-main-branch", dest="showMainBranch", default=False, action="store_true",
                      help="Also show reference for the main branch, not only for the PRs")
  parser.add_argument("--status", default="review",
                      help="Commit status which is considered trustworthy")
  parser.add_argument("--check-name", dest="checkName", default="",
                      help="Name of the check which we want to perform")
  parser.add_argument("--worker-index", dest="workerIndex", type=int, default=0,
                      help="Index for the current worker")
  parser.add_argument("--workers-pool-size", dest="workersPoolSize", type=int, default=1,
                      help="Total number of workers")
  parser.add_argument("--script", dest="script", default="",
                      help="Execute a script on the resulting PR")
  parser.add_argument("--timeout", dest="timeout", default=100, type=int,
                      help="Timeout between one run and the other")

  args = parser.parse_args()

  repo_name = args.branch.split("@")[0]
  branch_ref = args.branch.split("@")[1] if "@" in args.branch else "master"
  trusted = args.trusted.split(",")

  token = os.environ.get("GITHUB_TOKEN", None)
  opts = {"login_or_token": token} if token else {}
  gh = Github(**opts)

  repo = gh.get_repo(repo_name)
  # We get all the pull requests and put them in a dictionary sorted by ID
  pulls = repo.get_pulls(state="open", base=branch_ref)

  # Get the team for which we consider safe for test
  trustedTeam = None
  for team in repo.get_teams():
    if team.name == args.trustedTeam:
      trustedTeam = team

  while True:
    # Get only the updates
    sorted_pulls = []
    for x in pulls:
      try:
        print("Processing: %s" % x.number, file=sys.stderr)
        processOnePull(gh, x, repo, args, sorted_pulls, trustedTeam)
        print("Processing: %s. Done." % x.number, file=sys.stderr)
      except RuntimeError as e:
        print(e, file=sys.stderr)

    if args.showMainBranch:
      try:
        processMainBranch(repo, branch_ref, args, sorted_pulls)
      except RuntimeError as e:
        print(e, file=sys.stderr)

    sorted_pulls.sort(key=itemgetter("tested", "success", "random"))

    reviewed_pulls = [p for p in sorted_pulls if p["reviewed"]]
    not_tested_pulls = [p for p in reviewed_pulls if not p["tested"]]
    not_successful = [p for p in reviewed_pulls if p["tested"] and not p["success"]]

    actionable_pulls = not_tested_pulls or not_successful[:1] or reviewed_pulls[:1]

    for x in actionable_pulls:
      prId = "%(number)s@%(sha)s" % x
      print(prId)
      if args.script:
        err, out = getstatusoutput("%s %s" % (args.script, prId))
        print(out)

    printStats(gh)
    # No script provided, run in one shot mode.
    if not args.script:
      break
    time.sleep(args.timeout)

  dumpCommits(CACHED_COMMITS)
