#!/usr/bin/env python
from __future__ import print_function

from argparse import ArgumentParser
from commands import getstatusoutput
from glob import glob
from os.path import dirname, join
from sys import exit
import os
import sys
import re
from hashlib import sha1
from alibot_helpers.github_utilities import calculateMessageHash, setGithubStatus
from alibot_helpers.github_utilities import printStats
from alibot_helpers.github_utilities import loadCommits, dumpCommits

from github import Github

import atexit

CACHED_COMMITS = loadCommits()

if __name__ == "__main__":
  gh = Github(login_or_token=os.environ["GITHUB_TOKEN"])
  def atexit_handler():
    printStats(gh)
    dumpCommits(CACHED_COMMITS)
  atexit.register(atexit_handler)

  print("Github API used %s/%s" % gh.rate_limiting)
  parser = ArgumentParser()
  parser.add_argument("--work-dir", "-w", default="sw")
  parser.add_argument("--default", default="release")
  parser.add_argument("--devel-prefix", "-z", dest="develPrefix", default="")

  parser.add_argument("--pr", required=True,
                      help="Pull request which was checked in <org>/<project>#<nr>@ref format")
  parser.add_argument("--status", "-s", required=True,
                      help="Check which had the error")
  parser.add_argument("--dry-run", "-n", action="store_true", default=False,
                      help="Do not actually comment")
  parser.add_argument("--limit", "-l", default=50,
                      help="Max number of lines from the report")
  parser.add_argument("--logs-dest", dest="logsDest", default="rsync://repo.marathon.mesos/store/logs",
                      help="Destination path for logs")
  parser.add_argument("--log-url", dest="logsUrl", default="https://ali-ci.cern.ch/repo/logs",
                      help="Destination path for logs")

  args = parser.parse_args()

  if not "#" in args.pr:
    parser.error("You need to specify a pull request")
  if not "@" in args.pr:
    parser.error("You need to specify a commit this error refers to")

  repo_name, pr_parts = args.pr.split("#", 1)
  pr_id, pr_commit = pr_parts.split("@", 1)

  search_path = join(args.work_dir, "BUILD/*/log")
  print("Searching all logs matching: %s" % search_path, file=sys.stderr)
  globbed = glob(search_path)
  logs = [x for x in globbed
          if dirname(x).endswith(("latest" + "-" + args.develPrefix).strip("-"))]
  print("Found:\n%s" % "\n".join(logs), file=sys.stderr)
  error_log = ""
  for log in logs:
    err, out = getstatusoutput("cat %s | grep -e ': error:' -A 3 -B 3 || tail -n %s %s" % (log, args.limit, log))
    if err:
      print("Error while parsing logs", file=sys.stderr)
      print(out, file=sys.stderr)
      continue
    error_log += log + "\n"
    error_log += out

  error_log = "\n".join(error_log.split("\n")[0:args.limit])
  error_log.strip(" \n\t")

  logId = join(repo_name, pr_id, pr_commit, "fullLog.txt")
  getstatusoutput("rm -fr copy-logs && mkdir -p `dirname copy-logs/%s`" % logId)
  for log in logs:
    cmd = "cat %s >> copy-logs/%s" % (log, logId)
    print(cmd, file=sys.stderr)
    err, out = getstatusoutput(cmd)
    print(out, file=sys.stderr)
  err, out = getstatusoutput("cd copy-logs && rsync -av ./ %s" % (args.logsDest))
  if err:
    print("Error while copying logs to store.", file=sys.stderr)
    print(out, file=sys.stderr)

  logUrl = join(args.logsUrl, logId)

  repo = gh.get_repo(repo_name)
  # If the branch is not a PR, we should look for open issues for the
  # branch. This should really folded as a special case of the PR case.
  if not pr_id.isdigit():
    branch = repo.get_branch(pr_id)
    sha = branch.commit.sha
    message = "Error while checking %s for %s:\n```\n%s\n```\nFull log [here](%s).\n" % (args.status, sha, error_log, logUrl)
    for issue in repo.get_issues(state="open"):
      # Look for open issues:
      # - If we find one which was opened for the same branch / sha / error message sha
      #   triplet, we consider having already commented.
      # - If we find one which was opened for the same branch / sha, but with a different
      #   error message sha, we close it (as we assume the error message is now different).
      # - If we find one which was opened for a different branch / sha
      #   pair, close it (as we assume it's now obsolete since the branch
      #   points to something else).
      # - If no issue was found for the given branch, create one and add a comment
      #   about the failure.
      messageSha = calculateMessageHash(message)
      if issue.title.startswith("Error while checking branch %s@%s:%s" % (pr_id, sha, messageSha)):
        print("Issue still valid. Exiting.", file=sys.stderr)
        exit(0)
      if issue.title.startswith("Error while checking branch %s@%s" % (pr_id, sha)):
        print("Issue is about something different. Updating.", file=sys.stderr)
        issue.create_comment(body="Error for commit %s has changed.\n" % sha + message)
        issue.edit(title="Error while checking branch %s@%s:%s" % (pr_id, sha, messageSha))
        exit(0)
      if issue.title.startswith("Error while checking branch %s@" % pr_id):
        issue.create_comment("Branch was updated. Closing issue.", file=sys.stderr)
        issue.edit(state="close")
        continue
    # The first time we report an issue with a commit, we do so as issue body.
    # Subsequent changes will be reported as comments.
    setGithubStatus(gh, Namespace(commit=sha, status=args.status + "/error", message="", url=""), CACHED_COMMITS)
    issue = repo.create_issue(title="Error while checking branch %s@%s:%s" % (pr_id, sha, messageSha),
                              body=message)
    exit(0)

  pr = repo.get_pull(int(pr_id))
  commit = CACHED_COMMITS.get(pr_commit) or repo.get_commit(pr_commit)
  CACHED_COMMITS[pr_commit] = commit

  sha = commit.sha
  message = "Error while checking %s for %s:\n```\n%s\n```\nFull log [here](%s).\n" % (args.status, sha, error_log, logUrl)

  if args.dry_run:
    print("Will annotate %s" % commit)
    print(message)
    exit(0)

  for comment in pr.get_issue_comments():
    if comment.body.startswith("Error while checking %s for %s" % (args.status, sha)):
      if comment.body != message:
        print("Comment was different. Updating", file=sys.stderr)
        comment.edit(body=message)
        exit(0)
      print("Found same comment for the same commit", file=sys.stderr)
      exit(0)
  setGithubStatus(gh, Namespace(commit=sha, status=args.status + "/error", message="", url=""), CACHED_COMMITS)
  pr.create_issue_comment(body=message)
